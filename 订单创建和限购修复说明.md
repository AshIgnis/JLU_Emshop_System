# 订单创建和限购功能修复说明

## 修复时间
2025年10月16日 11:15

## 问题描述

### 问题1: 订单创建失败
**错误信息**: `[json.exception.type_error.302] type must be number, but is null`

**原因**: Java服务器解析CREATE_ORDER命令时，addressId参数解析失败，可能包含空格或格式问题。

### 问题2: 限购功能漏洞
**现象**: 用户购买限购商品达到限额后，如果不支付订单，仍然可以返回购物车重新购买。

**原因**: 系统在订单创建时就创建了购买记录（`user_purchase_records`），即使用户没有支付，限购额度已经被占用。这导致：
- 用户创建订单但不支付时，限购额度被占用
- 用户可以通过反复"创建订单-取消订单"来绕过限购

## 修复方案

### 修复1: 订单创建参数解析增强
**文件**: `java/src/main/java/emshop/EmshopNettyServer.java`

**改进内容**:
```java
// 修复前
long addressId = Long.parseLong(parts[1]);
String couponCode = parts.length > 2 && !parts[2].equals("0") ? parts[2] : null;

// 修复后
long addressId = 0;
try {
    addressId = Long.parseLong(parts[1].trim());  // 去除空格
} catch (NumberFormatException e) {
    handlerLogger.error("Invalid addressId format: {}", parts[1], e);
    return "{\"success\":false,\"message\":\"地址ID格式错误\",\"error_code\":400}";
}
String couponCode = parts.length > 2 && !parts[2].equals("0") && !parts[2].trim().isEmpty() 
    ? parts[2].trim() : null;  // 增强验证
```

**效果**: 
- 更健壮的参数解析
- 友好的错误提示
- 避免空字符串被当作有效优惠券代码

### 修复2: 购买记录延迟创建机制
**文件**: `cpp/services/OrderService.cpp`

**核心改进**: **将购买记录的创建时机从"订单创建"改为"订单支付"**

#### 修改1: createOrderFromCart函数
```cpp
// 移除原来在订单创建时的购买记录创建代码
// ========== 创建用户购买记录（用于限购统计）==========
// 此处代码已删除

// 改为注释说明
// ========== 注意: 购买记录在支付成功后创建，而不是订单创建时 ==========
// 这样可以避免"创建订单但未支付"时限购额度被占用的问题
// 用户只有在完成支付后，才会真正消耗限购额度
```

#### 修改2: processPayment函数
```cpp
// 在支付成功后添加购买记录创建逻辑
// ========== 支付成功后创建购买记录（用于限购统计）==========
// 查询订单明细
std::string items_sql = "SELECT oi.product_id, oi.quantity, o.user_id "
                       "FROM order_items oi "
                       "JOIN orders o ON oi.order_id = o.order_id "
                       "WHERE oi.order_id = " + std::to_string(order_id);
json items_result = executeQuery(items_sql);

if (items_result["success"].get<bool>() && !items_result["data"].empty()) {
    long user_id = items_result["data"][0]["user_id"].get<long>();
    
    for (const auto& item : items_result["data"]) {
        long pid = item["product_id"].get<long>();
        int qty = item["quantity"].get<int>();
        
        // 插入购买记录
        std::string purchase_record_sql = 
            "INSERT INTO user_purchase_records (user_id, product_id, quantity, order_id, status) "
            "VALUES (" + std::to_string(user_id) + ", " + std::to_string(pid) + ", " + 
            std::to_string(qty) + ", " + std::to_string(order_id) + ", 'valid')";
        
        executeQuery(purchase_record_sql);
    }
}
```

## 修复效果

### 限购功能改进
1. **订单创建阶段**
   - ✅ 检查用户是否超过限购数量
   - ✅ 如果超过，拒绝创建订单
   - ❌ **不创建购买记录**（关键改进）

2. **订单支付阶段**
   - ✅ 支付成功后才创建购买记录
   - ✅ 购买记录状态为'valid'
   - ✅ 限购额度真正被消耗

3. **订单取消/退款阶段**
   - ✅ 订单取消时，触发器自动将购买记录状态改为'cancelled'
   - ✅ 退款成功时，触发器自动将购买记录状态改为'refunded'
   - ✅ 存储过程检查限购时只统计status='valid'的记录

### 业务流程示例

#### 场景1: 正常购买流程
```
1. 用户加入购物车 (限购商品2件，用户未购买过)
   → 检查限购: PASS (0/2)
   
2. 创建订单
   → 检查限购: PASS (0/2)
   → 创建订单成功
   → 不创建购买记录 ⭐
   
3. 支付订单
   → 支付成功
   → 创建购买记录 (qty=2, status='valid') ⭐
   → 限购额度: 2/2
   
4. 再次购买
   → 检查限购: FAIL (2/2)
   → 拒绝加入购物车 ✅
```

#### 场景2: 创建订单但不支付
```
1. 用户加入购物车 (限购商品2件)
   → 检查限购: PASS (0/2)
   
2. 创建订单
   → 检查限购: PASS (0/2)
   → 创建订单成功
   → 不创建购买记录 ⭐
   
3. 用户未支付，取消订单
   → 订单状态: cancelled
   → 无购买记录 ⭐
   
4. 用户再次购买
   → 检查限购: PASS (0/2)
   → 可以正常购买 ✅
```

#### 场景3: 购买后申请退款
```
1. 用户购买并支付 (限购商品2件)
   → 创建购买记录 (qty=2, status='valid')
   → 限购额度: 2/2
   
2. 用户申请退款
   → 退款审核通过
   → 触发器更新: status='refunded' ⭐
   
3. 用户再次购买
   → 检查限购: PASS (0/2) 
   → 只统计status='valid'的记录 ✅
   → 可以正常购买
```

## 数据库触发器

系统依赖的触发器（已存在于数据库升级脚本中）:

```sql
CREATE TRIGGER update_purchase_record_on_refund
AFTER UPDATE ON orders
FOR EACH ROW
BEGIN
    -- 如果订单状态变为已取消或已退款，更新购买记录
    IF NEW.status IN ('cancelled', 'refunded') 
       AND OLD.status NOT IN ('cancelled', 'refunded') THEN
        UPDATE user_purchase_records 
        SET status = NEW.status
        WHERE order_id = NEW.order_id;
    END IF;
END
```

## 测试建议

1. **测试限购基本功能**
   - 购买限购商品达到限额
   - 验证无法继续购买

2. **测试未支付场景**
   - 创建订单但不支付
   - 验证限购额度未被占用
   - 验证可以再次购买

3. **测试退款场景**
   - 购买商品并支付
   - 申请退款并审核通过
   - 验证限购额度释放
   - 验证可以再次购买

4. **测试订单取消场景**
   - 创建订单
   - 取消订单
   - 验证限购额度未被占用

## 部署步骤

1. ✅ 修改Java代码 (`EmshopNettyServer.java`)
2. ✅ 修改C++代码 (`OrderService.cpp`)
3. ✅ 重新编译JNI库 (`build_oop_jni.bat`)
4. ✅ 复制DLL到Java项目
5. ✅ 重新编译Java项目 (`mvn clean compile`)
6. ⏳ 重启服务器
7. ⏳ 测试功能

## 注意事项

1. **数据库要求**: 确保已执行 `add_purchase_limit.sql` 创建存储过程和触发器
2. **向后兼容**: 修改不影响已有订单数据
3. **性能影响**: 支付时增加了购买记录插入操作，但由于是在事务内，影响可忽略
4. **日志增强**: 支付成功时会记录购买记录创建日志，便于问题排查

## 相关文件

- `java/src/main/java/emshop/EmshopNettyServer.java` - 订单创建参数解析
- `cpp/services/OrderService.cpp` - 订单创建和支付逻辑
- `cpp/add_purchase_limit.sql` - 存储过程和触发器
- `cpp/create_purchase_limit_procedure.sql` - 单独的存储过程创建脚本
